name: Run tests defined in a folder

on:
  workflow_dispatch:
    inputs:
      configuration:
        type: string
        description: 'Configuration for the test run'
        required: true

run-name: Run test action - ${{ fromJson(inputs.configuration).test-folder }}

# Define environment variables that are used across the workflow
# It is easier to change it here than in every job
env:
  POSTGRES_IMAGE: >-
    ${{
      (
        fromJson(inputs.configuration).services.postgresql.enabled ) &&
        format('postgres:{0}', fromJson(inputs.configuration).services.postgresql.version
      ) || ''
    }}
  POSTGRES_USER: ${{ fromJson(inputs.configuration).services.postgresql.user }}
  POSTGRES_PASSWORD: ${{ fromJson(inputs.configuration).services.postgresql.password }}
  POSTGRES_DB: ${{ fromJson(inputs.configuration).services.postgresql.db }}
  POSTGRES_PORT: ${{ fromJson(inputs.configuration).services.postgresql.port }}
  TEST_FOLDER_NAME: ${{ fromJson(inputs.configuration).test-folder }}
  TEST_FOLDER_PATH: ${{ github.workspace }}/${{ fromJson(inputs.configuration).test-folder }}
  K8S_CLUSTER_DIST: ${{ fromJson(inputs.configuration).k8s-cluster.dist }}
  CZERTAINLY_VERSION: ${{ fromJson(inputs.configuration).czertainly.version }}

jobs:

  test:
    name: Run test folder action - ${{ fromJson(inputs.configuration).test-folder }}
    runs-on: ubuntu-latest

    services:
      postgres:
        # Workaround for conditional startup of the service described here: https://github.com/actions/runner/issues/822
        # The `env` context does not work here, so we need to use expression
        image: >-
          ${{
            (
              fromJson(inputs.configuration).services.postgresql.enabled ) &&
              format('postgres:{0}', fromJson(inputs.configuration).services.postgresql.version
            ) || ''
          }}
        env:
          POSTGRES_USER: ${{ env.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ env.POSTGRES_PASSWORD }}
          POSTGRES_DB: ${{ env.POSTGRES_DB }}
        # The `env` context does not work here, so we need to use expression
        ports:
          - ${{ fromJson(inputs.configuration).services.postgresql.port }}:5432
        # Set health checks to wait until postgres has started
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      mail:
        # Workaround for conditional startup of the service described here: https://github.com/actions/runner/issues/822
        # The `env` context does not work here, so we need to use expression
        image: >-
          ${{
            (
              fromJson(inputs.configuration).services.mail.enabled ) &&
              format('mailserver/docker-mailserver:{0}', fromJson(inputs.configuration).services.mail.version
            ) || ''
          }}
        # The `env` context does not work here, so we need to use expression
        ports:
          - ${{ fromJson(inputs.configuration).services.mail.port }}:25
        env:
          SMTP_ONLY: 1
          OVERRIDE_HOSTNAME: czertainly.helm

    steps:
      # Print the value of the input `configuration` to the log
      - name: Print inputs
        run: |
          echo '${{ inputs.configuration }}' | jq .

      # Check out the repository
      - uses: actions/checkout@v4

      # Initialize database with the data from the initdb folder
      - name: Initialize database
        env:
          PGPASSWORD: ${{ env.POSTGRES_PASSWORD }}
        run: |
          search_dir=/the/path/to/base/dir
          for entry in "$TEST_FOLDER_PATH/initdb"/*
          do
            psql -h localhost -U $POSTGRES_USER -d $POSTGRES_DB -f $TEST_FOLDER_PATH/initdb/init-czertainlydb.sql
            echo "$entry"
          done
          psql -h localhost -U $POSTGRES_USER -d $POSTGRES_DB -f $TEST_FOLDER_PATH/initdb/init-czertainlydb.sql

      # Create k8s cluster based on the distribution specified in the configuration
      - name: Create k8s cluster - ${{ env.K8S_CLUSTER_DIST }}
        uses: ./.github/actions/create-k8s-cluster
        with:
          dist: ${{ env.K8S_CLUSTER_DIST }}

      # Set up Helm for the cluster to install Helm charts CZERTAINLY and Testkube
      - name: Set up Helm
        uses: azure/setup-helm@v3
        with:
          version: v3.11.1

      - name: Install CZERTAINLY
        run: |
          echo "Installing CZERTAINLY version $CZERTAINLY_VERSION"
          kubectl create namespace czertainly
          helm install --namespace czertainly -f $TEST_FOLDER_PATH/czertainly-values.yaml czertainly-tlm \
            oci://harbor.3key.company/czertainly-helm/czertainly --version $CZERTAINLY_VERSION --timeout 600s

      - name: Installing Helm repositories
        run: |
          helm repo add kubeshop https://kubeshop.github.io/helm-charts

      - name: Deploy Testkube using Helm
        run: |-
          helm upgrade --install --atomic --timeout 600s testkube kubeshop/testkube --namespace testkube --create-namespace

      - name: Create Testkube CRDs
        run: |
          kubectl apply -f ${{ github.workspace }}/${{ fromJson(inputs.configuration).test-folder }}/tests --recursive

      # Running test
      #- name: Run tests
      #  id: run_test
      #  uses: kubeshop/testkube-docker-action@v1
      #  env:
      #    KUBECONFIG: ${{ github.workspace }}/.kube/config
      #  with:
      #    command: run
      #    resource: test
      #    parameters: curl -f

      - name: Setup Testkube
        uses: kubeshop/setup-testkube@v1
        with:
          namespace: testkube

      - name: Run test
        run: |
          testkube run test czertainly-auth-test -f